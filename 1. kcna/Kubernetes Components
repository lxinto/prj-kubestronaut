Kubernetes Components


1. The role of the kubelet and how it interacts with the CRI (Container Runtime Interface)

    - often referenced as being the node of a kubernetes cluster but it runs both on the nodes and the control plane 
    - kubelet maintains the pods. makes use of the Pod Spec, a description of a Pod in Yaml or JSON and makes sures the pods are healthy, up and running.
    - Kubelet is an agent that runs on each node in a Kubernetes cluster and is responsible for managing the node's pods and containers. While Kubelet does interact with the Container Runtime to manage containers, it is not directly responsible for running them.

2. The role of the kube-scheduler

    - control plane process which is started as a static pod 
    - determines valid nodes according to constaints and resources
    - 

3. The role of the kube-proxy

    - runs as a DaemonSet on every isntance in the cluster
    - started as a normal pod NOT a static pod.
    - communicates with the API server and dynamically configures TCP/UDP and SCTP forwarding on any system that runs it
    - Kube-Proxy is a network proxy that runs on each node in a Kubernetes cluster and is responsible for managing the node's network traffic. It is not involved in running containers.

4. The role of the kubeapi-server

    - main gateway for access. is used by everyone including users and k8s components to communicate with eachother 
    - RESTful api interface

5. The role of etcd

    - key/value store
    - handles leader elections, network partitions
    - handles machine failures in a highly available configuration
    - used by k8s as the "source of truth" - information backing store for k8s
    - in production environment there should be an odd number of etcd instances running, ideally 5.
    - ETCD cluster communicates with eachother using RAFT protocol

6. Container Runtimes and the differences between high level and low level runtimes

The Container Runtime is directly responsible for running containers in a Kubernetes node. It is the software component that manages the lifecycle of containers, including starting, stopping, and monitoring them. Examples of container runtimes include Containerd and cri-o.



    low level runtime 
        - specifically tasked with spawning and running contianers
        - interacts with low level linux components: namespaces and cgroups
        - runc is the reference implementation of a low level container runtime
        - low level runtimes are typically installed as a component of a high level container runtime / container engine


    high level runtime
        - often reffered to as container engine
        - containerD is a high level runtime. it was created by and used within docker, later was donated to CNCF.
        - operated at high level and manages entine container lifecycle: pulling container images, storing them and etc.

7. The hierarchy of Kubernetes components - From Cluster to Node to Pod to Container

8. What is the CCM (Cloud Controller Manager) and where this would reside in a Kubernetes cluster

9. Control Manager

    - controllers are control loops taht monitor the stae of your clsuter
    - controllers will make or request changes as required
    - controllers include: Replication Controller, Node Controller, and Deployment Controller

10. Cloud Controller Manager

    - bridges functionality of the cloud provider or kubernetes.
    - a LoadBalancer service is a good example of CCM in use, for example, the use of a LoadBalancer in K8S may result in the creation of a Cloud Provided LoadBalacner

11. Core DNS

    - 





Control Plane Components

1. kube-apiserver
    - The front door to the Kubernetes cluster
    - All communication with the cluster (kubectl, UI, etc.) goes through this REST API.

2. etcd
    - A key-value store for all cluster data (like a database).
    - Stores the cluster’s configuration, state, secrets, etc.

3. kube-scheduler
    - The component that assigns pods to nodes.
    -  Decides where a new pod should run based on resource needs, node health, policies, etc.

4. kube-controller-manager
    - Runs various controllers that monitor and reconcile desired state.
    - Keeps the cluster in the desired state by reacting to changes (e.g., if a node dies, reschedule pods).
    - key controllers: 
        •	Node controller
        •	Replication controller
        •	Job controller
        •	Endpoints controller

5. cloud controller manager
    - Integrates with cloud providers (like AWS, GCP).
    - Handles cloud-specific logic (e.g., load balancers, volumes).


Worker Node Components

1. kubelet
    - An agent running on each node.
    - Talks to the API server, ensures containers are running as expected on that node.

2. kube proxy
    - Network component running on each node
    - Handles network routing to make services reachable (via iptables or IPVS).

3. container runtime
    - software to run containers (condainerd, cri-o, docker)
    - actually starts and stops containers. interacts directly with containers




Pod Lifecycle 

1.	You run kubectl apply -f pod.yaml.
2.	kubectl talks to kube-apiserver.
3.	Pod info is saved in etcd.
4.	kube-scheduler picks a node.
5.	kubelet on the chosen node gets the pod spec and tells the container runtime to start it.
6.	kube-proxy ensures the pod is reachable.
7.	Controllers keep watching and reconciling.